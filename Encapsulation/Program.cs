using System;

namespace Encapsulation
{
    class Program
    {
        static void Main(string[] args)
        {
            //Encapsulation - начина да си скрием имплементацията. Дава възможност за гъвкавост на кода, намалява сложността на кода, промените остават локални и ни позволяа да правим валидации. Идеята е да скрием сложната имплементация на нещо и да направим кода по-четим и по-лесен за поддръжка. Идеята е да скрием ненужна за външния свят информация, това на е сайбър секюрити (не е за да не ни хакнат)! Енкапсулация няма нищо общо със секюрити! 
            //Това с колата и енджина е пример за добра енкапсулация, защото портебителя има старт и стоп и не се интересува от сложността на енджина и тя не му се показва!!! Не е нужно да показваме на външния свят методи и пропъртита, които не го интересуват и само ще му усложнят живота! Така ако има нужда да променим нещо го правим локално в класа и не се налага да променяме на много места! 
            //Правим публични само необходими неща!
            //List<T> е добър пример за добра енкапсулация, дава ни само нужното за да работим с него и не ни занимава с това как работи (например вътрешния масив)!!!

            //factory design pattern - споменаха на упражнението да си погледнем!

            //this можем да подаваме като параметри на други методи

            //Да избягваме private класове и private интерфейси. private са филдовете.

            //Пропъртитата дефолтно са internal. 
            //Internal дава достъп на всички класове във същия проект.

            //fn+q включвал вентилатора на макс

            //Когато видим в грешките да ни пише Inconsistent accessibility това означава че опитваме да доступим нещо (клас) с по- макла достъпност (например ние сме интърнал, пък онова е прайвет)

            //private<protected<internal<public - достъпност

            //assembly == project

            //Можем да слагаме аксес модифаяри и на гетери и сетъри в пропърти, но само на единия, не може и на двата в едно пропърти! Те взимат модифайъра на пропъртито, но на единия можем да кажем друго.

            //Validation - сетерите са удобни за прости валидации. Когато искаме да сложим валидации се използват прайвет филдове с публик пропъртита! Конструкторите могат да използват прайвет сетери с валидираща логика.

            // Mutable Objects == changeable - use the same memory location (StringBuilder, List); 
            //if we have private mutable fields are still not encapsulated
            // return this.friends;//като върнем референтен тип така (от гетер - виж примера в Mutable Objects), стойността се взима по референция и стойността всеки може да я променя, екапсулация няма! За да нямаме този проблем трябва да използваме IReadOnlyCollection за да енкапсулираме колекции!(това е интерфейс, който листа наследява)
            //.AsReadOnly(); връщаме и ще гърми ако някой се опита да го промени (виж примера в Mutable Objects )!

            //Immutable Objects == unchangeable - create new memory every time they're modified (string, int);

            //Полезни клавишни комбинации: Ctrl+ <- kурсора отива наляво в края на думта, така е и на дясно. Ctrl+Shift+<-  маркира по този начин! Shift+Home те праща в началото на реда, Shift+end те праща в края на реда!
            //React vs Angulat = 80:20 определено ни препоръчва React

            //Oсновен принцип в ООП е че всеки клас трябва да отговаря за едно нещо и да върши само него.

            //Често използвана архитектура в ООП (Engine class)
            //В папка Core се слага бизнес логиката, а в Models класовете, а в Common

            //Удобен метод: String.IsNullOrEmpty(value)

            //Хубаво е да чистим using - и, които не използваме! 
        }
    }
}
